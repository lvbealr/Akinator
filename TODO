[] - FIX FREE IN TREE (IN INFO STRUCT DESTRUCT)
[x] - FIND ROOT BY VALUE IN TREE
[x] - SHOW DATABASE

[] - режимы:
  [x] - отгадывать
    [x] - инициализация дерева начальным вопросом
    [x] - рекурсивный спуск
    [x] - функция для вопроса
    [x] - считывание нет/да
    [x] - специализация для binaryTreeNodeLink
    [x] - линковка нод в зависимости от ответа - да -> направо, нет -> налево
    [x] - для этого custom strcmp или просто сравнивать [0] символ akinator->userAnswer (char)? сделать ENUM для режимов
    [x] - рекурсивно опускаемся по ребрам да/нет
    [x] - если да/нет и у текущей ноды нет потомка по ребру ответа, спрашиваем в чем отличие
    [x] - функция для вопроса, чем отличается от последней ноды
    [x] - выход в меню
  [x] - выдать описание
    [x] - с помощью binaryTreeFindNode ищем ноду
    [x] - нужен стэк на char* чтобы возвращать описание (LIFO)
    [x] - одна общая рекурсивная функция подьема по родителю и пуша описания в стэк
    [x] - функция принта описания
    [x] - выход в меню
  [] - сравнить
    [] - короче в любом случае придется делать stack на char *
    [] - юзаем binaryFreeFindNode
    [] - в начале стэка для обоих персонажей разные характеристики (поднимаемся сверху и пушим в стэк), в конце общие - все ок
    [] - пока stack1.pop == stack2.pop печатаем их общие характеристики, потом НО [первый] и печатаем весь stack1, А [второй] - stack2
    [] - выход в меню
  [x] - показать базу данных
    [x] - делаем dump и открываем картинку в браузере
    [x] - выход в меню
  [] - выйти с сохранением
    [] - функция записи всего дерева в базу данных
    [] - прощание
  [x] - выйти без сохранения
    [x] - просто выход
    [x] - прощание

[x] - stack on char*
[x] - режим с аудио и без (добавить в структуру режим аудио/без аудио)
[] - функция озвучки (вход в вирт окруж, принт кода в файл, запуск файла, запуск аудио)
[] - печатать внезапные фразы деда
[] - enum for answers

КОМПАРАТОР:
есть два стэка

firstCharacter  = [__firstName__,  ...]
secondCharacter = [__secondName__, ...]

создаю еще три стэка

common     = [] // хранит общие характеристики
firstDiff  = [] // хранит отличные для первого объекта характеристики
secondDiff = [] // хранит отличные для второго объекта характеристики

идея:
    while по firstCharacter, пока (firstCharacter->size - 1 > 0) (нулевой элемент - имя - не нужен)

      если secondCharater->size - 1 > 0 (лежит что-то, кроме имени): сравниваем

        если (firstNode == secondNode) (т. е. одинаковые свойства)
          нужно проверить на "да" и "нет"

          если (firstNode == firstNode->parent->right)
            пушим в common просто firstNode->data или secondNode->data
          иначе
            пушим в common "not " + firstNode->data

        иначе
          если (firstNode == firstNode->parent->right)
            пушим в firstDiff просто firstNode->data

          иначе
            пушим в firstDiff "not " + firstNode->data

          если (secondNode == secondNode->parent->right)
            пушим в secondDiff просто secondNode->data

          иначе
            пушим в secondDiff "not " + secondNode->data

      иначе
        до конца считываем первый стэк с проверками

        while (firstCharacter->size - 1)
          если (firstNode == firstNode->parent->right)
            пушим в firstDiff просто firstNode->data
          иначе
            пушим в firstDiff "not " + firstNode->data

аналогично по второму стэку (даже если в firstCharacter закончатся элементы,
                            в secondCharacter могут некоторые остаться)